Victor Frenkel
vgf2103
Operating System HW 1

1. 1.19: What is the purpose of interrupts? How does an interrupt differ from a trap? Can traps be generated intentionally by a user program? If so, for what purpose?
	- Interrupts are a signals sent to the processor which inform it that an event has taken place. A trap is a software generated interrupt used to handle execution errors and events whereas an interrupt can be created by hardware as well. Traps can be generated intentionally by the user program with a special instruction (in x86 assembly, the "int" instruction). A user program can use a trap to request a privileged service from the kernel, such as reading or writing a file. System calls are a major use of the trap.


2. 1.20: Direct memory access is used for high-speed I/O devices in order to avoid increasing the CPUâ€™s execution load.

    How does the CPU interface with the device to coordinate the transfer?
    	- the host writes a DMA command block that contains information regarding the transfer to be completed (source, destination, size) and writes the address of this command block to the DMA controller. The DMA controller takes care of the transfer with the device.

    How does the CPU know when the memory operations are complete?
    	- The CPU receives an interrupt signal from the device.

    The CPU is allowed to execute other programs while the DMA controller is transferring data. Does this process interfere with the execution of the user programs? If so, describe what forms of interference are caused.
    	- The DMA controller has to transfer data using the memory bus. When the DMA controller takes control of the memory bus, the CPU can not use it until the DMA controller releases it. This can cause a delay in the execution of the CPU's computations.


3. 1.21: Some computer systems do not provide a privileged mode of operation in hardware. Is it possible to construct a secure operating system for these computer systems? Give arguments both that it is and that it is not possible.
	- A sort of virtual machine would have to be constructed that checks to see if the operation being performed is valid before actually carrying it out. However, the security of such an OS would rely on the quality of its checks against invalid behavior. These checks could be very error-prone. Checking user instructions would also cause a performance hit; but on the other hand, there would be no time wasted in switching to privileged mode, and direct access to device controllers is faster.


4. 1.27: Describe some of the challenges of designing operating systems for mobile devices compared with designing operating systems for traditional PCs.
	- Mobile devices have limited battery power, an OS controlling utilization of available resources must be wary of this constraint. Mobile devices also have many more, and different, sensors than traditional PCs (GPS, accelerometers, etc.) that the OS has to provide access to and ensure that they are not abused or waste too much energy.

5. 2.21: What is the main advantage of the microkernel approach to system design? How do user programs and system services interact in a microkernel architecture? What are the disadvantages of using the microkernel approach?
	- The microkernel is very easy to extend as well as maintain. User programs and system services interact via message passing. The disadvantage of the microkernel approach is the high overhead of this inter process communication.

6. 2.22: What are the advantages of using loadable kernel modules?
	- Reduces bloat in the core kernel. The kernel doesn't have to load everything when it boots. When a change is made to a kernel module, just the module can be recompiled instead of the whole kernel.

7. What is the difference between kernel modules and a microkernel? Can loadable kernel modules be a replacement for microkernels? Explain in what ways they can (if any) and what ways they cannot (if any).
	- Kernel modules don't have to use message passing to communicate. Kernel modules rely on core kernel functionality to load themselves, such as the memory management unit (to reserve space for the module), so they can not replace these components which are found as separate processes in a microkernel. They can, however, be used to extend the core kernel with things like file systems and device drivers.

8. A primary task of an OS is to multiplex access to shared resources. Describe at-least two different ways in which this can be done, and state which way is usually applied to each of the following resources: CPU, Memory, Disk, Audio-device, Network-device, Display.
	- An OS can multiplex access to resources by letting each process use the resource one at a time, or it can service all processes at once and divide up the resource among all of them.
	
	CPU: At any given time, only one process is running on the CPU. OS handles order and time allowed to run via scheduler.
	Memory: Multiple areas of memory can be in use by multiple processes, OS usually creates a mapping to a region of memory for each process.
	Disk: The OS can queue up multiple requests and choose to service them together or separately, depending on the request.
	Audio-device: Multiple sound sources can be mixed and output at the same time by the audio device, all at once approach.
	Network-device: Communication to or from a process is serviced one after another.
	Display: Multiple processes can draw to a display all at once.


